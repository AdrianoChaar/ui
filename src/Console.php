<?php


// vim:ts=4:sw=4:et:fdm=marker:fdl=0

namespace atk4\ui;

/**
 * Console is a black square component resembling terminal window. It can be programmed
 * to run a job and output results to the user.
 */
class Console extends View implements \Psr\Log\LoggerInterface
{
    public $ui = 'inverted black segment';
    public $element = 'pre';

    /**
     * Will be set to $true while executing callback. Some methods
     * will use this to automatically schedule their own callback
     * and allowing you a cleaner syntax, such as.
     *
     * $console->setModel($user, 'generateReport');
     *
     * @var bool
     */
    protected $sseInProgress = false;

    /**
     * Stores object jsSSE which is used for communication.
     *
     * @var jsSSE
     */
    public $sse;

    /**
     * Bypass is used internally to capture and wrap direct output, but prevent jsSSE from
     * triggering output recurlively.
     *
     * @var bool
     */
    public $_output_bypass = false;

    /**
     * Set a callback method which will be executed with the output sent back to the terminal.
     *
     * Argument passed to your callback will be $this Console. You may perform calls
     * to methods such as
     *
     *   $console->output()
     *   $console->outputHTML()
     *
     * If you are using setModel, and if your model implements atk4\core\DebugTrait,
     * then you you will see debug information generated by $this->debug() or $this->log().
     *
     * This intercepts default application logging for the duration of the process.
     *
     * If you are using runCommand, then server command will be executed with it's output
     * (STDOUT and STDERR) redirected to the console.
     *
     * While inside a callback you may execute runCommand or setModel multiple times.
     *
     * @param callback    $callback callback which will be executed while displaying output inside console
     * @param bool|string $event    "true" would mean to execute on page load, string would indicate
     *                              js event. See first argument for View::js()
     *
     * @return $this
     */
    public function set($callback = null, $event = true)
    {
        if (!$callback) {
            throw new Exception('Please specify the $callback argument');
        }

        $this->sse = $this->add('jsSSE');
        $this->sse->set(function () use ($callback) {
            $this->sseInProgress = true;

            try {
                ob_start(function ($content) {
                    if ($this->_output_bypass) {
                        return $content;
                    }

                    $output = '';
                    $this->sse->echoFunction = function ($str) use (&$output) {
                        $output .= $str;
                    };
                    $this->output($content);
                    $this->sse->echoFunction = false;

                    return $output;
                }, 2);

                call_user_func($callback, $this);
            } catch (\atk4\core\Exception $e) {
                $lines = explode("\n", $e->getHTMLText());

                foreach ($lines as $line) {
                    $this->outputHTML($line);
                }
            } catch (\Error $e) {
                $this->output('Error: '.$e->getMessage());
            } catch (\Exception $e) {
                $this->output('Exception: '.$e->getMessage());
            }
            $this->sseInProgress = false;
        });

        if ($event) {
            $this->js($event, $this->sse);
        }

        return $this;
    }

    /**
     * Output a single line to the console.
     *
     * @param string $message
     * @param array  $context
     *
     * @return $this
     */
    public function output($message, array $context = [])
    {
        $this->outputHTML(htmlspecialchars($message), $context);

        return $this;
    }

    /**
     * Output un-escaped HTML line. Use this to send HTML.
     *
     * @todo Use $message as template and fill values from $context in there.
     *
     * @param string $message
     * @param array  $context
     *
     * @return $this
     */
    public function outputHTML($message, $context = [])
    {
        $this->_output_bypass = true;
        $this->sse->send($this->js()->append($message.'<br/>'));
        $this->_output_bypass = false;

        return $this;
    }

    /**
     * Executes a JavaScript action.
     *
     * @param jsExpressionable $js
     *
     * @return $this
     */
    public function send($js)
    {
        $this->_output_bypass = true;
        $this->sse->send($js);
        $this->_output_bypass = false;

        return $this;
    }

    /**
     * Executes command passing along escaped arguments.
     *
     * Will also stream stdout / stderr as the comand executes.
     * once command terminates method will return the exit code.
     *
     * This method can be executed from inside callback or
     * without it.
     */
    /*
    public function runCommand($exec, $args = [])
    {
        if (!$this->sseInProgress) {
            $this->set(function () {
                $this->runCommand($exec, $args);
            });

            return;
        }


        // not implemented here
        //
        //
    }
     */

    /**
     * Execute method of a certain model. That's a short-hand method
     * for running:.
     *
     * $app->add('Console')->setModel(new User($db), 'generateReports');
     *
     * You can enable output from inside your method if you:
     *
     *  - implement \atk4\core\DebugTrait in your model
     *  - use $this->debug() or $this->info()
     *  - if you wish to get log from other objects, be sure to switch debug on with $obj->debug = true;
     *
     * @param \atk4\data\Model $model
     * @param string           $method
     * @param array            $args
     *
     * @return \atk4\data\Model
     */
    public function setModel(\atk4\data\Model $model, $method = null, $args = [])
    {
        if (!$method) {
            throw new Exception('You must specify $method argument');
        }
        if (!$this->sseInProgress) {
            $this->set(function () use ($model, $method, $args) {
                $this->setModel($model, $method, $args);
            });

            return $model;
        }

        // temporarily override app logging
        if (isset($model->app)) {
            $old_logger = $model->app->logger;
            $model->app->logger = $this;
        }

        $this->output('--[ Executing '.get_class($model).'->'.$method.' ]--------------');
        $model->debug = true;
        $result = call_user_func_array([$model, $method], $args);
        $this->output('--[ Result: '.json_encode($result).' ]------------');

        if (isset($model->app)) {
            $model->app->logger = $old_logger;
        }

        return $model;
    }

    // Methods below implements \Psr\Log\LoggerInterface

    /**
     * System is unusable.
     *
     * @param string $message
     * @param array  $context
     */
    public function emergency($message, array $context = [])
    {
        $this->outputHTML("<font color='pink'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Action must be taken immediately.
     *
     * @param string $message
     * @param array  $context
     */
    public function alert($message, array $context = [])
    {
        $this->outputHTML("<font color='pink'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Critical conditions.
     *
     * @param string $message
     * @param array  $context
     */
    public function critical($message, array $context = [])
    {
        $this->outputHTML("<font color='pink'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Runtime errors that do not require immediate action but should typically
     * be logged and monitored.
     *
     * @param string $message
     * @param array  $context
     */
    public function error($message, array $context = [])
    {
        $this->outputHTML("<font color='pink'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Exceptional occurrences that are not errors.
     *
     * @param string $message
     * @param array  $context
     */
    public function warning($message, array $context = [])
    {
        $this->outputHTML("<font color='pink'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Normal but significant events.
     *
     * @param string $message
     * @param array  $context
     */
    public function notice($message, array $context = [])
    {
        $this->outputHTML("<font color='yellow'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Interesting events.
     *
     * @param string $message
     * @param array  $context
     */
    public function info($message, array $context = [])
    {
        $this->outputHTML("<font color='gray'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Detailed debug information.
     *
     * @param string $message
     * @param array  $context
     */
    public function debug($message, array $context = [])
    {
        $this->outputHTML("<font color='cyan'>".htmlspecialchars($message).'</font>', $context);
    }

    /**
     * Logs with an arbitrary level.
     *
     * @param mixed  $level
     * @param string $message
     * @param array  $context
     */
    public function log($level, $message, array $context = [])
    {
        $this->$level($message, $context);
    }
}
